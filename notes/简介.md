### 第一章 简介

最初的计算机并没有'操作系统',它从头到尾只执行一个程序,并且程序能访问计算机中的所有
资源.

#### 操作系统的出现
操作系统的出现,就是为了合理利用计算机资源.
* 资源利用率  
在某个程序等待外部操作时(如文件读取,网络数据传输),此时cpu闲置,操作系统便可以调度另一个
程序运行.
* 公平性
操作系统为各个程序分配资源、cpu使用时间等,而不是任由一个程序从头执行到尾
* 便利性
在计算多个任务时,应编写多个程序,每个程序执行一个任务并在必要时相互通信.

#### 进程与线程
* 进程
可以看作一个程序就是一个进程,比如运行的各个软件,它们都是独立的一个进程.
* 线程
一个进程包含了许多线程,同一个进程中的这些线程共同使用内存地址空间,可以访问相同的变量
线程的出现是为了将职责划分的更细,之前进程拥有资源分配和独立调度的权力.引入线程后,独立调度的能力
被赋予给了线程,于是更加轻量,更加符合现代多核操作系统.


#### 线程带来的问题
* 安全性问题

一个进程可以有多个线程,这多个线程共享了进程拥有的资源,如内存地址空间.如果多个线程去修改它们都能访问到的变量
就可能会引起变量的最终结果值与我们预期的不一样.
```java
    public class Test{
        int value=0;
        
        public int getNext(){
            return value++;
        }      
    }
```
上面例子就是线程不安全的,因为value++实际分为了三步:从内存读取value,将value+1,将结果写会内存
现在有a,b两个线程,a线程读取value为0,存入cpu缓存后b开始执行.此时b从内存读取到的也是0,然后他们都在
0的基础上+1,最后都将结果1写回内存.  我们期望的时方法执行两次,value应该为2,但此时value为1,这就是安全性问题

上面情况称为:"竞态条件" -> value是否正确取决于a,b两个线程的执行顺序.但我们没办法保证cpu对线程的调度顺序以及缓存等.

* 活跃性问题
单线程中不小心写出不是期望中的死循环就是活跃性问题.
多线程也存在这样的问题,如A线程等待B释放资源,B却也在等待A释放资源.造成它们互相等待.

* 性能问题
cpu在切换线程时,会保存加载需要切换的两个线程的一些信息,这会带来性能开销.

